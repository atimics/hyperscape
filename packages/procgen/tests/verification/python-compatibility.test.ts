/**
 * Verification Tests: Python Compatibility
 *
 * These tests verify that the TypeScript implementation produces
 * the same results as the original Python implementation.
 *
 * Reference values were generated using the original Python tree-gen
 * with specific seeds and parameters.
 *
 * To regenerate reference values, run the Python code:
 * ```python
 * import random
 * random.seed(12345)
 * for i in range(10):
 *     print(f"  {random.random():.15f},")
 * ```
 */

import { describe, it, expect } from "vitest";
import { SeededRandom } from "../../src/math/Random.js";
import { Tree } from "../../src/core/Tree.js";
import { QUAKING_ASPEN, BLACK_OAK, PALM } from "../../src/params/index.js";

describe("Python Compatibility", () => {
  describe("Mersenne Twister RNG", () => {
    /**
     * Python reference values generated with:
     * ```python
     * import random
     * random.seed(12345)
     * for i in range(10):
     *     print(f"  {random.random():.15f},")
     * ```
     */
    const PYTHON_RANDOM_SEED_12345 = [
      0.416619872545341, 0.010169169457068, 0.825206509253743,
      0.298639855199593, 0.368411689488476, 0.193661349045074,
      0.566008168728861, 0.161687823929368, 0.12426688428353, 0.432936268009916,
    ];

    it("produces same sequence as Python for seed 12345", () => {
      const rng = new SeededRandom(12345);

      for (let i = 0; i < PYTHON_RANDOM_SEED_12345.length; i++) {
        const tsValue = rng.random();
        const pyValue = PYTHON_RANDOM_SEED_12345[i]!;

        // Allow small floating point differences
        expect(tsValue).toBeCloseTo(pyValue, 10);
      }
    });

    /**
     * Python reference for seed 42:
     * ```python
     * import random
     * random.seed(42)
     * for i in range(10):
     *     print(f"  {random.random():.15f},")
     * ```
     */
    const PYTHON_RANDOM_SEED_42 = [
      0.6394267984578837, 0.025010755222666936, 0.27502931836911926,
      0.22321073814882275, 0.7364712141640124, 0.6766994874229113,
      0.8921795677048454, 0.08693883262941615, 0.4219218196852704,
      0.029797219438070344,
    ];

    it("produces same sequence as Python for seed 42", () => {
      const rng = new SeededRandom(42);

      for (let i = 0; i < PYTHON_RANDOM_SEED_42.length; i++) {
        const tsValue = rng.random();
        const pyValue = PYTHON_RANDOM_SEED_42[i]!;

        expect(tsValue).toBeCloseTo(pyValue, 10);
      }
    });

    it("uniform matches Python random.uniform", () => {
      // Python: random.seed(100); random.uniform(-1, 1)
      // Result: 0.03426891461009926 -> scaled to [-1,1] = -0.9314621707798015
      const rng = new SeededRandom(100);
      const val = rng.uniform(-1, 1);

      // First random value for seed 100
      const rng2 = new SeededRandom(100);
      const raw = rng2.random();

      // uniform(-1, 1) = -1 + (1 - (-1)) * raw = -1 + 2 * raw
      const expected = -1 + 2 * raw;
      expect(val).toBeCloseTo(expected, 10);
    });
  });

  describe("Tree Structure Verification", () => {
    /**
     * Reference values generated by running:
     * python3 packages/tree-gen/scripts/verify-against-python.py
     *
     * These exact values were computed by Python's random module with
     * the tree-gen algorithm, so our TypeScript implementation must
     * produce identical values.
     */
    /**
     * These values were generated by the Python verification script that
     * accurately simulates the random call order in gen.py:
     * 1. createBranches() → calls uniform(-1,1) for tree_scale (scale_var)
     * 2. For single trunk: rollRight(randInRange(0, 360)) → 1 random call
     * 3. make_stem() → calls uniform(-1,1) for length_child_max
     * 4. calc_stem_length() → calls uniform(-1,1) for trunk length (for depth 0)
     *
     * Note: points_for_floor_split() is only called when branches[0] > 1
     */
    const PYTHON_REFERENCE = {
      quakingAspen_12345: {
        seed: 12345,
        scale_var: -0.16676025490931767,
        tree_scale: 12.499719235272046,
        trunk_length: 12.499719235272046,
        trunk_radius: 0.1874957885290807,
        base_length: 3.7499157705816137,
      },
      blackOak_42: {
        seed: 42,
        scale_var: 0.2788535969157675,
        tree_scale: 10.557707193831535,
        trunk_length: 10.557707193831535,
        trunk_radius: 0.1900387294889676,
        base_length: 0.5278853596915768,
      },
      palm_100: {
        seed: 100,
        scale_var: -0.7086614897917394,
        tree_scale: 11.874015530624781,
        trunk_length: 11.874015530624781,
        trunk_radius: 0.1781102329593717,
        base_length: 11.280314754093542,
      },
    };

    it("Quaking Aspen tree_scale matches Python (seed 12345)", () => {
      const tree = new Tree(QUAKING_ASPEN, { seed: 12345 });
      const data = tree.generate();

      expect(data.treeScale).toBeCloseTo(
        PYTHON_REFERENCE.quakingAspen_12345.tree_scale,
        10,
      );
    });

    it("Quaking Aspen trunk_length matches Python (seed 12345)", () => {
      const tree = new Tree(QUAKING_ASPEN, { seed: 12345 });
      const data = tree.generate();

      expect(data.trunkLength).toBeCloseTo(
        PYTHON_REFERENCE.quakingAspen_12345.trunk_length,
        10,
      );
    });

    it("Quaking Aspen trunk_radius matches Python (seed 12345)", () => {
      const tree = new Tree(QUAKING_ASPEN, { seed: 12345 });
      const data = tree.generate();

      const trunk = data.stems.find((s) => s.depth === 0)!;
      expect(trunk.radius).toBeCloseTo(
        PYTHON_REFERENCE.quakingAspen_12345.trunk_radius,
        10,
      );
    });

    it("Quaking Aspen base_length matches Python (seed 12345)", () => {
      const tree = new Tree(QUAKING_ASPEN, { seed: 12345 });
      const data = tree.generate();

      expect(data.baseLength).toBeCloseTo(
        PYTHON_REFERENCE.quakingAspen_12345.base_length,
        10,
      );
    });

    it("Black Oak tree_scale matches Python (seed 42)", () => {
      const tree = new Tree(BLACK_OAK, { seed: 42 });
      const data = tree.generate();

      expect(data.treeScale).toBeCloseTo(
        PYTHON_REFERENCE.blackOak_42.tree_scale,
        10,
      );
    });

    it("Black Oak trunk_length matches Python (seed 42)", () => {
      const tree = new Tree(BLACK_OAK, { seed: 42 });
      const data = tree.generate();

      expect(data.trunkLength).toBeCloseTo(
        PYTHON_REFERENCE.blackOak_42.trunk_length,
        10,
      );
    });

    it("Palm tree_scale matches Python (seed 100)", () => {
      const tree = new Tree(PALM, { seed: 100 });
      const data = tree.generate();

      expect(data.treeScale).toBeCloseTo(
        PYTHON_REFERENCE.palm_100.tree_scale,
        10,
      );
    });

    it("generates expected stem count for Quaking Aspen", () => {
      const tree = new Tree(QUAKING_ASPEN, { seed: 12345 });
      const data = tree.generate();

      // The exact count depends on the parameters and RNG sequence
      expect(data.stems.length).toBeGreaterThan(10);

      // Trunk should exist at depth 0
      const trunk = data.stems.find((s) => s.depth === 0);
      expect(trunk).toBeDefined();
      expect(trunk!.parentIndex).toBeNull();
    });

    it("generates consistent branch depths", () => {
      const tree = new Tree(QUAKING_ASPEN, { seed: 12345 });
      const data = tree.generate();

      // Count stems by depth
      const depthCounts = new Map<number, number>();
      for (const stem of data.stems) {
        const count = depthCounts.get(stem.depth) ?? 0;
        depthCounts.set(stem.depth, count + 1);
      }

      // Should have exactly 1 trunk (or number specified by branches[0])
      expect(depthCounts.get(0)).toBe(QUAKING_ASPEN.branches[0]);

      // Should have level 1 and 2 branches
      expect(depthCounts.get(1)).toBeGreaterThan(0);
      expect(depthCounts.get(2)).toBeGreaterThan(0);
    });

    it("child stems reference valid parents", () => {
      const tree = new Tree(QUAKING_ASPEN, { seed: 12345 });
      const data = tree.generate();

      for (const stem of data.stems) {
        if (stem.parentIndex !== null) {
          expect(stem.parentIndex).toBeGreaterThanOrEqual(0);
          expect(stem.parentIndex).toBeLessThan(data.stems.length);

          const parent = data.stems[stem.parentIndex];
          expect(parent).toBeDefined();
          expect(parent!.depth).toBe(stem.depth - 1);
        }
      }
    });
  });

  describe("Different Tree Types", () => {
    it("Palm generates 2-level tree as expected", () => {
      const tree = new Tree(PALM, { seed: 42 });
      const data = tree.generate();

      // Palm has levels=2, so only depth 0 and 1
      const maxDepth = Math.max(...data.stems.map((s) => s.depth));
      expect(maxDepth).toBeLessThanOrEqual(1);

      // Should have trunk + fronds
      expect(data.stems.filter((s) => s.depth === 0).length).toBe(1);
      expect(data.stems.filter((s) => s.depth === 1).length).toBeGreaterThan(0);
    });

    it("Black Oak generates expected structure", () => {
      const tree = new Tree(BLACK_OAK, { seed: 42 });
      const data = tree.generate();

      // Black Oak has levels=3
      const maxDepth = Math.max(...data.stems.map((s) => s.depth));
      expect(maxDepth).toBe(2);

      // Should have more complex branching than Palm
      expect(data.stems.length).toBeGreaterThan(50);
    });
  });

  describe("Coordinate System", () => {
    it("trunk grows along positive Y axis (after Z-up to Y-up transform)", () => {
      const tree = new Tree(QUAKING_ASPEN, { seed: 12345 });
      const data = tree.generate();

      const trunk = data.stems.find((s) => s.depth === 0)!;

      // First point should be near origin
      const firstPoint = trunk.points[0]!;
      expect(firstPoint.position.x).toBeCloseTo(0, 1);
      expect(firstPoint.position.y).toBeCloseTo(0, 1);

      // Note: In the raw data, z is up. The transform happens at geometry stage.
      // The trunk should grow in +Z in raw data
      const lastPoint = trunk.points[trunk.points.length - 1]!;
      expect(lastPoint.position.z).toBeGreaterThan(firstPoint.position.z);
    });
  });
});
